<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><title class="next-head">React Patterns</title><meta name="viewport" content="initial-scale=1.0, width=device-width" class="next-head"/><meta name="description" content="React patterns from beginners to advanced developers. Simple examples, short descriptions, and quality advice." class="next-head"/><link rel="preload" href="/_next/static/PwmtmX~mjJnDQvy9nsnBa/pages/index.js" as="script"/><link rel="preload" href="/_next/static/PwmtmX~mjJnDQvy9nsnBa/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/PwmtmX~mjJnDQvy9nsnBa/pages/_error.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.7681cca98b4a3ef17f19.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.028fa83e33a29d6a259c.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-f97fb34c0d5ce0a28da4.js" as="script"/><link rel="stylesheet" href="/_next/static/css/styles.542184d2.chunk.css"/></head><body><div id="__next"><div style="max-width:33em"><div><h1 id="react-模式（中文版）-on-github">React 模式（中文版） <a href="https://github.com/keelii/reactpatterns.cn" target="_blank" rel="noreferrer">on Github</a></h1><h2 id="目录">目录</h2><ul><li><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-function-component">函数组件 (Function component)</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%84-destructuring-props">属性解构 (Destructuring props)</a></li><li><a href="#jsx-%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%B1%95%E5%BC%80-jsx-spread-attributes">JSX 中的属性展开 (JSX spread attributes)</a></li><li><a href="#%E5%90%88%E5%B9%B6%E8%A7%A3%E6%9E%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%85%B6%E5%AE%83%E5%80%BC-merge-destructured-props-with-other-values">合并解构属性和其它值 (Merge destructured props with other values)</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93-conditional-rendering">条件渲染 (Conditional rendering)</a></li><li><a href="#%E5%AD%90%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B-children-types">子元素类型 (Children types)</a></li><li><a href="#%E6%95%B0%E7%BB%84%E5%81%9A%E4%B8%BA%E5%AD%90%E5%85%83%E7%B4%A0-array-as-children">数组做为子元素 (Array as children)</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%81%9A%E4%B8%BA%E5%AD%90%E5%85%83%E7%B4%A0-function-as-children">函数做为子元素 (Function as children)</a></li><li><a href="#%E6%B8%B2%E6%9F%93%E5%B1%9E%E6%80%A7-render-prop">渲染属性 (Render prop)</a></li><li><a href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92-children-pass-through">子组件的传递 (Children pass-through)</a></li><li><a href="#%E4%BB%A3%E7%90%86%E7%BB%84%E4%BB%B6-proxy-component">代理组件 (Proxy component)</a></li><li><a href="#%E6%A0%B7%E5%BC%8F%E7%BB%84%E4%BB%B6-style-component">样式组件 (Style component)</a></li><li><a href="#%E7%BB%84%E7%BB%87%E4%BA%8B%E4%BB%B6-event-switch">组织事件 (Event switch)</a></li><li><a href="#%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6-layout-component">布局组件 (Layout component)</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6-container-component">容器组件 (Container component)</a></li><li><a href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-higher-order-component">高阶组件 (Higher-order component)</a></li><li><a href="#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87-state-hoisting">状态提升 (State hoisting)</a></li><li><a href="#%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5-controlled-input">受控输入 (Controlled input)</a></li></ul><h2 id="函数组件-function-component">函数组件 (Function component)</h2><p><a href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" target="_blank" rel="noreferrer">函数组件</a> 是最简单的一种声明可复用组件的方法</p><p>他们就是一些简单的函数。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi there!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><p>从第一个形参中获取属性集 (props)</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><p>按自己的需要可以在函数组件中定义任意变量</p><p><strong>最后一定要返回你的 React 组件。</strong></p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">let</span> style = {
    <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&quot;bold&quot;</span>,
    <span class="hljs-attr">color</span>: context.color
  };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>Hi {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><p>使用 <code>defaultProps</code> 为任意必有属性设置默认值</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
Greeting.defaultProps = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Guest&quot;</span>
};</code></pre><hr/><h2 id="属性解构-destructuring-props">属性解构 (Destructuring props)</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noreferrer">解构赋值</a> 是一种 JavaScript 特性。  </p><p>出自 ES2015 版的 JavaScript 新规范。</p><p>所以看起来可能并不常见。</p><p>好比字面量赋值的反转形式。</p><pre><code class="hljs language-js" metaString=""><span class="hljs-keyword">let</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chantastic&quot;</span> };
<span class="hljs-keyword">let</span> { name } = person;</code></pre><p>同样适用于数组。</p><pre><code class="hljs language-js" metaString=""><span class="hljs-keyword">let</span> things = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>];
<span class="hljs-keyword">let</span> [first, second] = things;</code></pre><p>解构赋值被用在很多 <a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-function-component" target="_blank" rel="noreferrer">函数组件</a> 中。</p><p>下面声明的这些组件是相同的。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ name }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><p>有一种语法可以在对象中收集剩余属性。</p><p>叫做 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noreferrer">剩余参数</a>，看起来就像这样。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ name, ...restProps }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><p>那三个点 (<code>...</code>) 会把所有的剩余属性分配给 <code>restProps</code> 对象</p><p>然而，你能使用 <code>restProps</code> 做些什么呢？</p><p>继续往下看...</p><hr/><h2 id="jsx-中的属性展开-jsx-spread-attributes">JSX 中的属性展开 (JSX spread attributes)</h2><p>属性展开是 <a href="https://reactjs.org/docs/introducing-jsx.html" target="_blank" rel="noreferrer">JSX</a> 中的一个的特性。</p><p>它是一种语法，专门用来把对象上的属性转换成 JSX 中的属性</p><p>参考上面的 <a href="#%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%84-(Destructuring-props)" target="_blank" rel="noreferrer">属性解构</a>,<br/>我们可以 <strong>扩散</strong> <code>restProps</code> 对象的所有属性到 div 元素上</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ name, ...restProps }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...restProps</span>}&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><p>这让 <code>Gretting</code> 组件变得非常灵活。</p><p>我们可以通过传给 Gretting 组件 DOM 属性并确定这些属性一定会被传到 <code>div</code> 上</p><pre><code class="hljs language-jsx" metaString="">&lt;Greeting name=<span class="hljs-string">&quot;Fancy pants&quot;</span> className=<span class="hljs-string">&quot;fancy-greeting&quot;</span> id=<span class="hljs-string">&quot;user-greeting&quot;</span> /&gt;</code></pre><p>避免传递非 DOM 属性到组件上。
解构赋值是如此的受欢迎，是因为它可以分离 <code>组件特定的属性</code> 和 <code>DOM/平台特定属性</code></p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ name, ...platformProps }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...platformProps</span>}&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><hr/><h2 id="合并解构属性和其它值-merge-destructured-props-with-other-values">合并解构属性和其它值 (Merge destructured props with other values)</h2><p>组件就是一种抽象。</p><p>好的抽象是可以扩展的。</p><p>比如说下面这个组件使用 <code>class</code> 属性来给按钮添加样式。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;btn&quot;</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
}</span></code></pre><p>一般情况下这样做就够了，除非我们需要扩展其它的样式类</p><pre><code class="hljs language-jsx" metaString="">&lt;MyButton className=<span class="hljs-string">&quot;delete-btn&quot;</span>&gt;Delete...&lt;<span class="hljs-regexp">/MyButton&gt;</span></code></pre><p>在这个例子中把 <code>btn</code> 替换成 <code>delete-btn</code></p><p><a href="#JSX-%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%B1%95%E5%BC%80-(JSX-spread-attributes)" target="_blank" rel="noreferrer">JSX 中的属性展开</a> 对先后顺序是敏感的</p><p>扩散属性中的 <code>className</code> 会覆盖组件上的 <code>className</code>。</p><p>我们可以改变它两的顺序，但是目前来说 <code>className</code> 只有 <code>btn</code>。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> {<span class="hljs-attr">...props</span>} <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;btn&quot;</span> /&gt;</span>;
}</span></code></pre><p>我们需要使用解构赋值来合并入参 props 中的 <code>className</code> 和基础的（组件中的） <code>className</code>。
可以通过把所有的值放在一个数组里面，然后使用一个空格连接它们。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">{ className, ...props }</span>) </span>{
  <span class="hljs-keyword">let</span> classNames = [<span class="hljs-string">&quot;btn&quot;</span>, className].join(<span class="hljs-string">&quot; &quot;</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{classNames}</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
}</span></code></pre><p>为了保证 <code>undefined</code> 不被显示在 className 上，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values_2" target="_blank" rel="noreferrer">默认值</a>。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">{ className = <span class="hljs-string">&quot;&quot;</span>, ...props }</span>) </span>{
  <span class="hljs-keyword">let</span> classNames = [<span class="hljs-string">&quot;btn&quot;</span>, className].join(<span class="hljs-string">&quot; &quot;</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{classNames}</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
}</span></code></pre><h2 id="条件渲染-conditional-rendering">条件渲染 (Conditional rendering)</h2><p>不可以在一个组件声明中使用 if/else 语句
You can&#x27;t use if/else statements inside a component declarations.<br/>所以可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noreferrer">条件（三元）运算符</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation" target="_blank" rel="noreferrer">短路计算</a>。</p><h3 id="如果"><code>如果</code></h3><pre><code class="hljs language-jsx" metaString="">{
  condition &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `truthy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;
}</code></pre><h3 id="除非"><code>除非</code></h3><pre><code class="hljs language-jsx" metaString="">{
  condition || <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `falsy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;
}</code></pre><h3 id="如果-否则"><code>如果-否则</code></h3><pre><code class="hljs language-jsx" metaString="">{
  condition ? (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `truthy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
  ) : (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `falsy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
  );
}</code></pre><h2 id="子元素类型-children-types">子元素类型 (Children types)</h2><p>很多类型都可以做为 React 的子元素。</p><p>多数情况下会是 <code>数组</code> 或者 <code>字符串</code>。</p><h3 id="字符串-string">字符串 <code>String</code></h3><pre><code class="hljs language-jsx" metaString="">&lt;div&gt;Hello World!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><h3 id="数组-array">数组 <code>Array</code></h3><pre><code class="hljs language-jsx" metaString="">&lt;div&gt;{[<span class="hljs-string">&quot;Hello &quot;</span>, &lt;span&gt;World&lt;<span class="hljs-regexp">/span&gt;, &quot;!&quot;]}&lt;/</span>div&gt;</code></pre><h2 id="数组做为子元素-array-as-children">数组做为子元素 (Array as children)</h2><p>将数组做为子元素是很常见的。</p><p>列表是如何在 React 中被绘制的。</p><p>我们使用 <code>map()</code> 方法创建一个新的 React 元素数组</p><pre><code class="hljs language-jsx" metaString="">&lt;ul&gt;
  {[<span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;second&quot;</span>].map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{item}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  ))}
&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>这和使用字面量数组是一样的。</p><pre><code class="hljs language-jsx" metaString="">&lt;ul&gt;{[<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>first<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>, &lt;li&gt;second&lt;<span class="hljs-regexp">/li&gt;]}&lt;/u</span>l&gt;</code></pre><p>这个模式可以联合解构、JSX 属性扩散以及其它组件一起使用，看起来简洁无比</p><pre><code class="hljs language-jsx" metaString="">&lt;ul&gt;
  {arrayOfMessageObjects.map(<span class="hljs-function">(<span class="hljs-params">{ id, ...message }</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Message</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{id}</span> {<span class="hljs-attr">...message</span>} /&gt;</span>
  ))}
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></code></pre><h2 id="函数做为子元素-function-as-children">函数做为子元素 (Function as children)</h2><p>React 组件不支持函数类型的子元素。</p><p>然而 <a href="#%E6%B8%B2%E6%9F%93%E5%B1%9E%E6%80%A7-render-prop" target="_blank" rel="noreferrer">渲染属性</a> 是一种可以创建组件并以函数作为子元素的模式。</p><h2 id="渲染属性-render-prop">渲染属性 (Render prop)</h2><p>这里有个组件，使用了一个渲染回调函数 children。</p><p>这样写并没有什么用，但是可以做为入门的简单例子。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">const</span> Width = <span class="hljs-function">(<span class="hljs-params">{ children }</span>) =&gt;</span> children(<span class="hljs-number">500</span>);</code></pre><p>组件把 children 做为函数调用，同时还可以传一些参数。上面这个 <code>500</code> 就是实参。</p><p>为了使用这个组件，我们可以在调用组件的时候传入一个子元素，这个子元素就是一个函数。</p><pre><code class="hljs language-jsx" metaString="">&lt;Width&gt;{width =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>window is {width}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>}&lt;<span class="hljs-regexp">/Width&gt;</span></code></pre><p>我们可以得到下面的输出。</p><pre><code class="hljs language-jsx" metaString="">&lt;div&gt;<span class="hljs-built_in">window</span> is <span class="hljs-number">500</span>&lt;<span class="hljs-regexp">/div&gt;</span></code></pre><p>有了这个组件，我们就可以用它来做渲染策略。</p><pre><code class="hljs language-jsx" metaString="">&lt;Width&gt;
  {width =&gt; (width &gt; <span class="hljs-number">600</span> ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>min-width requirement met!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> : <span class="hljs-literal">null</span>)}
&lt;<span class="hljs-regexp">/Width&gt;</span></code></pre><p>如果有更复杂的条件判断，我们可以使用这个组件来封装另外一个新组件来利用原来的逻辑。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">const</span> MinWidth = <span class="hljs-function">(<span class="hljs-params">{ width: minWidth, children }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Width</span>&gt;</span>{width =&gt; (width &gt; minWidth ? children : null)}<span class="hljs-tag">&lt;/<span class="hljs-name">Width</span>&gt;</span></span>
);</code></pre><p>显然，一个静态的 <code>Width</code> 组件并没有什么用处，但是给它绑定一些浏览器事件就不一样了。下面有个实现的例子。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowWidth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">width</span>: <span class="hljs-number">0</span> };
  }

  componentDidMount() {
    <span class="hljs-keyword">this</span>.setState(
      { <span class="hljs-attr">width</span>: <span class="hljs-built_in">window</span>.innerWidth },
      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, ({ target }) =&gt;
        <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">width</span>: target.innerWidth })
      )
    );
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.children(<span class="hljs-keyword">this</span>.state.width);
  }
}</code></pre><p>许多开发人员都喜欢 <a href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-higher-order-component" target="_blank" rel="noreferrer">高阶组件</a> 来实现这种功能。但这只是个人喜好问题。</p><h2 id="子组件的传递-children-pass-through">子组件的传递 (Children pass-through)</h2><p>你可能会创建一个组件，这个组件会使用 <code>context</code> 并且渲染它的子元素。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeContextProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  getChildContext() {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">some</span>: <span class="hljs-string">&quot;context&quot;</span> };
  }

  render() {
    <span class="hljs-comment">// 如果能直接返回 `children` 就完美了</span>
  }
}</code></pre><p>你将面临一个选择。把 <code>children</code> 包在一个 div 中并返回，或者直接返回 <code>children</code>。第一种情况需要要你添加额外的标记（这可能会影响到你的样式）。第二种将产生一个没什么用处的错误。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-comment">// option 1: extra div</span>
<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;

<span class="hljs-comment">// option 2: unhelpful errors</span>
<span class="hljs-keyword">return</span> children;</code></pre><p>最好把 <code>children</code> 做为一种不透明的数据类型对待。React 提供了 <code>React.Children</code> 方法来处理 <code>children</code>。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">return</span> React.Children.only(<span class="hljs-keyword">this</span>.props.children);</code></pre><h2 id="代理组件-proxy-component">代理组件 (Proxy component)</h2><p><em>(我并不确定这个名字的准确叫法 <code>译：代理、中介、装饰?</code>)</em></p><p>按钮在 web 应用中随处可见。并且所有的按钮都需要一个 <code>type=&quot;button&quot;</code> 的属性。</p><pre><code class="hljs language-jsx" metaString="">&lt;button type=<span class="hljs-string">&quot;button&quot;</span>&gt;</code></pre><p>重复的写这些属性很容易出错。我们可以写一个高层组件来代理 <code>props</code> 到底层组件。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>
  &lt;button type=<span class="hljs-string">&quot;button&quot;</span> {...props}&gt;</code></pre><p>我们可以使用 <code>Button</code> 组件代替 <code>button</code> 元素，并确保 <code>type</code> 属性始终是 button。</p><pre><code class="hljs language-jsx" metaString="">&lt;Button /&gt;
<span class="hljs-comment">// &lt;button type=&quot;button&quot;&gt;&lt;button&gt;</span>

&lt;Button className=<span class="hljs-string">&quot;CTA&quot;</span>&gt;Send Money&lt;<span class="hljs-regexp">/Button&gt;
/</span><span class="hljs-regexp">/ &lt;button type=&quot;button&quot; class=&quot;CTA&quot;&gt;Send Money&lt;/</span>button&gt;</code></pre><h2 id="样式组件-style-component">样式组件 (Style component)</h2><p>这也是一种 <a href="#%E4%BB%A3%E7%90%86%E7%BB%84%E4%BB%B6-proxy-component" target="_blank" rel="noreferrer">代理组件</a>，用来处理样式。</p><p>假如我们有一个按钮，它使用了「primary」做为样式类。</p><pre><code class="hljs language-jsx" metaString="">&lt;button type=<span class="hljs-string">&quot;button&quot;</span> className=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</code></pre><p>我们使用一些单一功能组件来生成上面的结构。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">import</span> classnames <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;classnames&quot;</span>;

<span class="hljs-keyword">const</span> PrimaryBtn = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &lt;Btn {...props} primary /&gt;;

<span class="hljs-keyword">const</span> Btn = <span class="hljs-function">(<span class="hljs-params">{ className, primary, ...props }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>
    <span class="hljs-attr">className</span>=<span class="hljs-string">{classnames(</span>&quot;<span class="hljs-attr">btn</span>&quot;, <span class="hljs-attr">primary</span> &amp;&amp; &quot;<span class="hljs-attr">btn-primary</span>&quot;, <span class="hljs-attr">className</span>)}
    {<span class="hljs-attr">...props</span>}
  /&gt;</span>
);</span></code></pre><p>可以可视化的展示成下面的样子。</p><pre><code class="hljs language-jsx" metaString="">PrimaryBtn()
  ↳ Btn({<span class="hljs-attr">primary</span>: <span class="hljs-literal">true</span>})
    ↳ Button({<span class="hljs-attr">className</span>: <span class="hljs-string">&quot;btn btn-primary&quot;</span>}, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;button&quot;</span>})
      ↳ <span class="hljs-string">&#x27;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;/button&gt;&#x27;</span></code></pre><p>使用这些组件，下面的这几种方式会得到一致的结果。</p><pre><code class="hljs language-jsx" metaString="">&lt;PrimaryBtn /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Btn</span> <span class="hljs-attr">primary</span> /&gt;</span>
</span>&lt;button type=&quot;button&quot; className=&quot;btn btn-primary&quot; /&gt;</code></pre><p>这对于样式维护来说是非常好的。它将样式的所有关注点分离到单个组件上。</p><h2 id="组织事件-event-switch">组织事件 (Event switch)</h2><p>当我们在写事件处理函数的时候，通常会使用 <code>handle{事件名字}</code> 的命名方式。</p><pre><code class="hljs language-jsx" metaString="">handleClick(e) { <span class="hljs-comment">/* do something */</span> }</code></pre><p>当需要添加很多事件处理函数的时候，这些函数名字会显得很重复。这些函数的名字并没有什么价值，因为它们只代理了一些动作或者函数。</p><pre><code class="hljs language-jsx" metaString="">handleClick() { <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./actions/doStuff&quot;</span>)(<span class="hljs-comment">/* action stuff */</span>) }
handleMouseEnter() { <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">true</span> }) }
handleMouseLeave() { <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">false</span> }) }</code></pre><p>可以考虑写一个事件处理函数来根据不同的 <code>event.type</code> 来组织事件。</p><pre><code class="hljs language-jsx" metaString="">handleEvent({type}) {
  <span class="hljs-keyword">switch</span>(type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;click&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./actions/doStuff&quot;</span>)(<span class="hljs-comment">/* action dates */</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mouseenter&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">true</span> })
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mouseleave&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">false</span> })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`No case for event type &quot;<span class="hljs-subst">${type}</span>&quot;`</span>)
  }
}</code></pre><p>另外，对于简单的组件，你可以在组件中使用箭头函数直接调用导入的动作或者函数</p><pre><code class="hljs language-jsx" metaString="">&lt;div onClick={() =&gt; someImportedAction({ <span class="hljs-attr">action</span>: <span class="hljs-string">&quot;DO_STUFF&quot;</span> })}</code></pre><p>在遇到性能问题之前，不要担心性能优化。真的不要</p><h2 id="布局组件-layout-component">布局组件 (Layout component)</h2><p>布局组件表现为一些静态 DOM 元素的形式。它们一般并不需要经常更新。</p><p>就像下面的这个组件一样，两边各自渲染了一个 children。</p><pre><code class="hljs language-jsx" metaString="">&lt;HorizontalSplit
  leftSide={&lt;SomeSmartComponent /&gt;}
  rightSide={&lt;AnotherSmartComponent /&gt;}
/&gt;</code></pre><p>我们可以优化这个组件。</p><p>HorizontalSplit 组件是两个子组件的父元素，我们可以告诉组件永远都不要更新</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HorizontalSplit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  shouldComponentUpdate() {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  render() {
    &lt;FlexContainer&gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.leftSide}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      &lt;div&gt;{<span class="hljs-keyword">this</span>.props.rightSide}&lt;<span class="hljs-regexp">/div&gt;
    &lt;/</span>FlexContainer&gt;
  }
}</code></pre><h2 id="容器组件-container-component">容器组件 (Container component)</h2><p>「容器用来获取数据然后渲染到子组件上，仅仅如此。」<!-- -->—<a href="https://twitter.com/jasonbonta" target="_blank" rel="noreferrer">Jason Bonta</a></p><p>这有一个 <code>CommentList</code> 组件。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">const</span> CommentList = <span class="hljs-function">(<span class="hljs-params">{ comments }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {comments.map(comment =&gt; (
      </span>&lt;li&gt;
        {comment.body}-{comment.author}
      &lt;/li&gt;<span class="xml">
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre><p>我们可以创建一个新组件来负责获取数据渲染到上面的 <code>CommentList</code> 函数组件中。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">comments</span>: [] }
  }

  componentDidMount() {
    $.ajax({
      <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/my-comments.json&quot;</span>,
      <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,
      <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">comments</span> =&gt;</span>
        <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">comments</span>: comments});
    })
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CommentList</span> <span class="hljs-attr">comments</span>=<span class="hljs-string">{this.state.comments}</span> /&gt;</span>
  }
}</span></code></pre><p>对于不同的应用上下文，我们可以写不同的容器组件。</p><h2 id="高阶组件-higher-order-component">高阶组件 (Higher-order component)</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" target="_blank" rel="noreferrer">高阶函数</a> 是至少满足下列一个条件的函数：</p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><p>所以高阶组件又是什么呢？</p><p>如果你已经用过 <a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6-container-component" target="_blank" rel="noreferrer">容器组件</a>, 这仅仅是一些泛化的组件, 包裹在一个函数中。</p><p>让我们以 <code>Greeting</code> 组件开始</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">const</span> Greeting = <span class="hljs-function">(<span class="hljs-params">{ name }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!name) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>连接中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};</code></pre><p>如果 <code>props.name</code> 存在，组件会渲染这个值。否则将展示「连接中...」。现在来添加点高阶的感觉</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">const</span> Connect = <span class="hljs-function"><span class="hljs-params">ComposedComponent</span> =&gt;</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-keyword">super</span>();
      <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span> };
    }

    componentDidMount() {
      <span class="hljs-comment">// this would fetch or connect to a store</span>
      <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Michael&quot;</span> });
    }

    render() {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComposedComponent</span> {<span class="hljs-attr">...this.props</span>} <span class="hljs-attr">name</span>=<span class="hljs-string">{this.state.name}</span> /&gt;</span>;
    }
  };</span></code></pre><p>这是一个返回了入参为组件的普通函数</p><p>接着，我们需要把 <code>Greeting</code> 包裹到 <code>Connect</code> 中</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">const</span> ConnectedMyComponent = Connect(Greeting);</code></pre><p>这是一个强大的模式，它可以用来获取数据和给定数据到任意 <a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-function-component" target="_blank" rel="noreferrer">函数组件</a> 中。</p><h2 id="状态提升-state-hoisting">状态提升 (State hoisting)</h2><p><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-function-component" target="_blank" rel="noreferrer">函数组件</a> 没有状态 (就像名字暗示的一样)。</p><p>事件是状态的变化。</p><p>它们的数据需要传递给状态化的父 <a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6-container-component" target="_blank" rel="noreferrer">容器组件</a></p><p>这就是所谓的「状态提升」。</p><p>它是通过将回调从容器组件传递给子组件来完成的</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Name</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{newName</span> =&gt;</span> alert(newName)} /&gt;;
  }
}

const Name = ({ onChange }) =&gt; (
  </span>&lt;input onChange={e =&gt; onChange(e.target.value)} /&gt;
);</code></pre><p><code>Name</code> 组件从 <code>NameContainer</code> 组件中接收 <code>onChange</code> 回调，并在 input 值变化的时候调用。</p><p>上面的 <code>alert</code> 调用只是一个简单的演示，但它并没有改变状态</p><p>让我们来改变 <code>NameContainer</code> 组件的内部状态。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span> };
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Name</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{newName</span> =&gt;</span> this.setState({ name: newName })} /&gt;;
  }
}</span></code></pre><p>这个状态 <em>被提升</em> 到了容器中，通过添加回调函数，回调中可以更新本地状态。这就设置了一个很清晰边界，并且使功能组件的可重用性最大化。</p><p>这个模式并不限于函数组件。因为函数组件没有生命周期事件，你也可以在类组件中使用这种模式。</p><p><em><a href="#%E5%8F%97%E6%8E%A7%E8%BE%93%E5%85%A5-controlled-input" target="_blank" rel="noreferrer">受控输入</a> 是一种与状态提升同时使用时很重要的模式</em></p><p><em>(最好是在一个状态化的组件上处理事件对象)</em></p><h2 id="受控输入-controlled-input">受控输入 (Controlled input)</h2><p>讨论受控输入的抽象并不容易。让我们以一个不受控的（通常）输入开始。</p><pre><code class="hljs language-jsx" metaString="">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> /&gt;</code></pre><p>当你在浏览器中调整此输入时，你会看到你的更改。 这个是正常的</p><p>受控的输入不允许 DOM 变更，这使得这个模式成为可能。通过在组件范围中设置值而不是直接在 DOM 范围中修改</p><pre><code class="hljs language-jsx" metaString="">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=<span class="hljs-string">&quot;This won&#x27;t change. Try it.&quot;</span> /&gt;</code></pre><p>显示静态的输入框值对于用户来说并没有什么用处。所以，我们从状态中传递一个值到 input 上。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlledNameInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span> };
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.name}</span> /&gt;</span>;
  }
}</span></code></pre><p>然后当你改变组件的状态的时候 input 的值就自动改变了。</p><pre><code class="hljs language-jsx" metaString=""><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.name}</span>
    <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> this.setState({ name: e.target.value })}
  /&gt;
);</span></code></pre><p>这是一个受控的输入框。它只会在我们的组件状态发生变化的时候更新 DOM。这在创建一致 UI 界面的时候非常有用。</p><p><em>如果你使用 <a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-function-component" target="_blank" rel="noreferrer">函数组件</a> 做为表单元素，那就得阅读 <a href="#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87-state-hoisting" target="_blank" rel="noreferrer">状态提升</a> 一节，把状态转移到上层的组件树上。</em></p></div></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{}},"page":"/","query":{},"buildId":"PwmtmX~mjJnDQvy9nsnBa","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/" src="/_next/static/PwmtmX~mjJnDQvy9nsnBa/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/PwmtmX~mjJnDQvy9nsnBa/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/static/PwmtmX~mjJnDQvy9nsnBa/pages/_error.js"></script><script src="/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/_next/static/chunks/commons.7681cca98b4a3ef17f19.js" async=""></script><script src="/_next/static/chunks/styles.028fa83e33a29d6a259c.js" async=""></script><script src="/_next/static/runtime/main-f97fb34c0d5ce0a28da4.js" async=""></script></body></html>